/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ./expParser.jj */
/*@egen*/options{                  
    STATIC = false;                              
}

PARSER_BEGIN(ExpressionParser)
package wvustat.math.expression;

import java.io.*;
import java.util.*;

public class ExpressionParser/*@bgen(jjtree)*/implements ExpressionParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTExpressionParserState jjtree = new JJTExpressionParserState();

/*@egen*/
    public ExpressionParser(){
        this(new StringReader(""));
    }
    
  	private static String compact(String str)
  	{
  		StringBuffer buf = new StringBuffer(str.length());
  		for (int i = 0; i < str.length(); i++)
  		{
  			if (str.charAt(i) != ' ' && str.charAt(i) != '\t' && str.charAt(i) != '\n' && str.charAt(i) != '\r')
  			{
  				buf.append(str.charAt(i));
  			}
  		}

  		return buf.toString();
  	}
  	
  	private static String fillAsterisk(String str) throws ParseException
  	{
  		StringBuffer buf = new StringBuffer(str.length());
  		StringTokenizer st = new StringTokenizer(compact(str), "+-*/^&|!=<>(),", true);
  		
  		String lastToken = "";
  		if(st.hasMoreTokens()){ 
  			lastToken = st.nextToken();
  			buf.append(isComposite(lastToken)? composite(lastToken): lastToken);
  		}
  		
  		
  		while (st.hasMoreTokens())
        {
            String token = st.nextToken();
            if (	(isNumber(lastToken,false) && "(".equals(token)) ||
            		(")".equals(lastToken) && (isNumber(token,true) || isComposite(token)) ) || 
				(")".equals(lastToken) && "(".equals(token)) ||
            	  	(")".equals(lastToken) && isIdentifier(token)) )
            {
            		buf.append("*");
            }
            
            if ( isIdentifier(lastToken) && "(".equals(token))
            {
            		if (FuncImplementation.getInstance(lastToken) == null)
            			throw new ParseException("Unsupported function: " + lastToken);
            }
            
            buf.append(isComposite(token)? composite(token): token);
            lastToken = token;
        }
  		
  		return buf.toString();
  	}
  	
  	private static boolean isNumber(String s, boolean endwithE){
  		try{
  			if (endwithE && (s.charAt(s.length()-1) == 'e' || s.charAt(s.length()-1) == 'E'))
  				Double.parseDouble(s.substring(0, s.length()-1));
  			else
  				Double.parseDouble(s);
  		}catch(NumberFormatException ex){
  			return false;
  		}
  		
  		return true;
  	}
  	
  	private static boolean isComposite(String s){
  		if(isNumber(s, true)) return false;
  		
  		boolean ret = false;
  		int i = s.length() - 1;
  		while (!ret && i >= 1){
  			String numPart = s.substring(0, i);
  			String varPart = s.substring(i);
  			if (isNumber(numPart, false) && isIdentifier(varPart) && !varPart.equalsIgnoreCase("e")) 
  				ret = true;
  			i--;
  		}
  		return ret;
  	}
  	
  	private static String extractNumber(String s){
  		int i = s.length() - 1;
  		while (i >= 1){
  			String numPart = s.substring(0, i);
  			String varPart = s.substring(i);
  			if (isNumber(numPart, false) && isIdentifier(varPart) && !varPart.equalsIgnoreCase("e")) 
  				return numPart;
  			i--;
  		}
  		return "";
  	}
  	
  	private static String composite(String s){
  		String numPart = extractNumber(s);
  		String varPart = s.substring(numPart.length());
  		return numPart + "*" + varPart;  		
  	}
  	
  	private static boolean isIdentifier(String s){
  		if ( s.charAt(0) != '_' && !Character.isLetter(s.charAt(0)) )
  			return false;
  		
  		boolean ret = true;
  		int i = 1;
  		while (ret && i < s.length()){
  			if ( s.charAt(i) != '_' && !Character.isLetterOrDigit(s.charAt(i)) )
  				ret = false;
  			i++;
  		}
  		return ret;
  	}
  
    public Expression parse(String exp) throws ParseException{
        ReInit(new StringReader(fillAsterisk(fillAsterisk(exp))));
        return start();
    }

    public static void main(String args[]){
        System.out.println("Expression Parser test. Please enter " +
                           "expressions (one per line):");
        System.out.println("Enter EXIT to quit the program.");
        System.out.print(">");

        try{
            BufferedReader reader =
                new BufferedReader(new InputStreamReader(System.in));
            ExpressionParser ep = new ExpressionParser();
            String s = null;
            while((s = reader.readLine()) != null){
                if(s.equals("EXIT"))
                    break;
                try{
                	   System.out.println("fill asterisk: " + fillAsterisk(s));
                    Expression exp = ep.parse(s);
                    System.out.println("Parsed expression: " + exp.toString());

                    System.out.println("Variables:");
                    Map varMap = exp.getVariables();
                    Iterator it = varMap.keySet().iterator();
                    while(it.hasNext()){
                        String v = (String)it.next();
                        System.out.println("Variable name: " + v);
                    }
                    Vector v = exp.getVariableNames();
                    Map map=new HashMap();
                    for(int i=0; i<v.size(); i++){
                    	   System.out.println("Variable name: " + v.elementAt(i));
                    	   map.put(v.elementAt(i), new Double(1.0));
                    }
                    
                    exp.setVariables(map);
                    System.out.println("Value: " + exp.getValue());
                    System.out.println("derivative: " + exp.derivativeString("x") );
                    Expression derivExp;
                    System.out.println("derivative: " + (derivExp = ep.parse(exp.derivativeString("x"))) );
                    System.out.println("derivative value: " + derivExp.value(map));
                }catch(Exception e){
                    System.out.println(e.toString());
                }catch(Error err){
                	   System.out.println(err.toString());
                }

                System.out.print(">");
            }
            System.out.println("\nBye.");
        }catch(Exception e){
            System.out.println("Exception: " + e);
        }
    }
}

PARSER_END(ExpressionParser)

SKIP : {
    " " | "\t" | "\n" | "\r"
}

TOKEN : {
   <NUM_LITERAL : (["0" - "9"])+ 
       | (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
       | "." (["0"-"9"])+ (<EXPONENT>)?
       | (["0"-"9"])+ <EXPONENT>>
   |<BOOL_LITERAL : ("true" | "false")>
   |<#EXPONENT : ["e", "E"] (["+", "-"])?(["0"-"9"])+>
   |<STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            )
          )
      )*
      "\""
    >
}

TOKEN : {
    <IDENTIFIER : <LETTER> (<LETTER>|<DIGIT>)*>
   |<#LETTER : ["_", "A"-"Z", "a"-"z"]>
   |<#DIGIT : ["0"-"9"]>
}

TOKEN : {
    <GT : ">"> | <LT : "<"> | <EQ : "=="> | <GE : ">="> | <LE : "<="> | 
    <NE : "!="> | <AND : "&&"> | <OR : "||"> | <NOT : "!"> | <PLUS : "+"> | 
    <MINUS : "-"> | <MUL : "*"> | <DIV : "/"> | <POWER : "^">
}

Expression start() :
{}
{
    expression() <EOF> { return (Expression)jjtree.popNode(); }
   |<EOF> { throw new ParseException("Empty expression"); }
}

void expression() :
{}
{
    orExpression()
}

void orExpression() :
{
    Token op;
}
{
 andExpression() (/*@bgen(jjtree) #LogicalExp( 2) */
                  {
                    ASTLogicalExp jjtn001 = new ASTLogicalExp(JJTLOGICALEXP);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
                  }
                  try {
/*@egen*/( (op = <OR>) andExpression()/*@bgen(jjtree)*/
                                               {
                                                 jjtree.closeNodeScope(jjtn001,  2);
                                                 jjtc001 = false;
                                               }
/*@egen*/{
     jjtn001.setOperator(op.image);
 })/*@bgen(jjtree)*/
                  } catch (Throwable jjte001) {
                    if (jjtc001) {
                      jjtree.clearNodeScope(jjtn001);
                      jjtc001 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte001 instanceof RuntimeException) {
                      throw (RuntimeException)jjte001;
                    }
                    if (jjte001 instanceof ParseException) {
                      throw (ParseException)jjte001;
                    }
                    throw (Error)jjte001;
                  } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  2);
                    }
                  }
/*@egen*/)*
}

void andExpression() :
{
    Token op;
}
{
    relationalExpression() (/*@bgen(jjtree) #LogicalExp( 2) */
                            {
                              ASTLogicalExp jjtn001 = new ASTLogicalExp(JJTLOGICALEXP);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
                            }
                            try {
/*@egen*/( (op = <AND>) relationalExpression()/*@bgen(jjtree)*/
                                                                 {
                                                                   jjtree.closeNodeScope(jjtn001,  2);
                                                                   jjtc001 = false;
                                                                 }
/*@egen*/{
        jjtn001.setOperator(op.image);
    })/*@bgen(jjtree)*/
                            } catch (Throwable jjte001) {
                              if (jjtc001) {
                                jjtree.clearNodeScope(jjtn001);
                                jjtc001 = false;
                              } else {
                                jjtree.popNode();
                              }
                              if (jjte001 instanceof RuntimeException) {
                                throw (RuntimeException)jjte001;
                              }
                              if (jjte001 instanceof ParseException) {
                                throw (ParseException)jjte001;
                              }
                              throw (Error)jjte001;
                            } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001,  2);
                              }
                            }
/*@egen*/)*
}

void relationalExpression() :
{
    Token op;
}
{
    addictiveExpression() (/*@bgen(jjtree) #ComparisonExp( 2) */
        {
          ASTComparisonExp jjtn001 = new ASTComparisonExp(JJTCOMPARISONEXP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        ( (op = <GT> | op = <LT> | op = <EQ> | op= <GE> | op = <LE> | 
           op = <NE>) 
          addictiveExpression()/*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn001,  2);
                                 jjtc001 = false;
                               }
/*@egen*/{
              jjtn001.setOperator(op.image);
        })/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/
    )*
}

void addictiveExpression() :
{
    Token op;
}
{
    multiplicativeExpression() (/*@bgen(jjtree) #AddictiveExp( 2) */
        {
          ASTAddictiveExp jjtn001 = new ASTAddictiveExp(JJTADDICTIVEEXP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        ((op = <PLUS> | op = <MINUS>) multiplicativeExpression()/*@bgen(jjtree)*/
                                                                {
                                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                                  jjtc001 = false;
                                                                }
/*@egen*/{
            jjtn001.setOperator(op.image);
        })/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/
    )*
}

void multiplicativeExpression() :
{
    Token op;
}
{
    unaryExpression() (/*@bgen(jjtree) #MultiplicativeExp( 2) */
        {
          ASTMultiplicativeExp jjtn001 = new ASTMultiplicativeExp(JJTMULTIPLICATIVEEXP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        ((op = <MUL> | op = <DIV>) unaryExpression()/*@bgen(jjtree)*/
                                                    {
                                                      jjtree.closeNodeScope(jjtn001,  2);
                                                      jjtc001 = false;
                                                    }
/*@egen*/{
            jjtn001.setOperator(op.image);
        })/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/
    )*
}

void unaryExpression() :
{
    Token op;
}
{/*@bgen(jjtree) #UnaryExp( 1) */
    {
      ASTUnaryExp jjtn001 = new ASTUnaryExp(JJTUNARYEXP);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ( (op = <PLUS> | op = <MINUS> | op = <NOT>) exponentialExpression()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
    }
/*@egen*/
    {
        jjtn001.setOperator(op.image);
    })/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
      }
    }
/*@egen*/
   | (exponentialExpression())
}

void exponentialExpression() :
{
    Token op;
}
{
    notPlusMinusUnaryExpression() (/*@bgen(jjtree) #ExponentialExp( 2) */
        {
          ASTExponentialExp jjtn001 = new ASTExponentialExp(JJTEXPONENTIALEXP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (op = <POWER> unaryExpression())/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/
    )?
}

void notPlusMinusUnaryExpression() :
{}
{
     constant()
   | LOOKAHEAD(<IDENTIFIER> "(")
     function()
   | ( "(" expression() ")" )
   | variable()
}

void constant() :
{
    Token t;
}
{/*@bgen(jjtree) #LiteralExp( 0) */
   {
     ASTLiteralExp jjtn001 = new ASTLiteralExp(JJTLITERALEXP);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
   }
   try {
/*@egen*/
   ((t = <NUM_LITERAL>)/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn001,  0);
                         jjtc001 = false;
                       }
/*@egen*/{
        jjtn001.setInitValue(new Double(t.image));
    })/*@bgen(jjtree)*/
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001,  0);
     }
   }
/*@egen*/
   |/*@bgen(jjtree) #LiteralExp( 0) */
    {
      ASTLiteralExp jjtn002 = new ASTLiteralExp(JJTLITERALEXP);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/((t = <BOOL_LITERAL>)/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn002,  0);
                           jjtc002 = false;
                         }
/*@egen*/{
        jjtn002.setInitValue(new Boolean(t.image));
    })/*@bgen(jjtree)*/
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002,  0);
      }
    }
/*@egen*/
   |/*@bgen(jjtree) #LiteralExp( 0) */
    {
      ASTLiteralExp jjtn003 = new ASTLiteralExp(JJTLITERALEXP);
      boolean jjtc003 = true;
      jjtree.openNodeScope(jjtn003);
    }
    try {
/*@egen*/((t = <STRING_LITERAL>)/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn003,  0);
                             jjtc003 = false;
                           }
/*@egen*/{
        jjtn003.setInitValue(t.image.substring(1, t.image.length()-1));
    })/*@bgen(jjtree)*/
    } finally {
      if (jjtc003) {
        jjtree.closeNodeScope(jjtn003,  0);
      }
    }
/*@egen*/
}

void function() :
{
    String funcName;
    int numOfArg = 0;
}
{/*@bgen(jjtree) #FuncExp( numOfArg) */
    {
      ASTFuncExp jjtn001 = new ASTFuncExp(JJTFUNCEXP);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ( funcName = identifier()
      {
          jjtn001.setFunctionName(funcName);
      }
      "(" numOfArg = argumentList() ")"
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  numOfArg);
      }
    }
/*@egen*/
}

int argumentList() :
{
    int numOfArg = 0;
}
{
    (
        expression() { numOfArg++; } 
        ("," expression() { numOfArg++; })*
    )?
    {
        return numOfArg;
    } ")"
}

void variable() :
{
    String varName;
}
{/*@bgen(jjtree) #Variable( 0) */
    {
      ASTVariable jjtn001 = new ASTVariable(JJTVARIABLE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (varName = identifier()/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn001,  0);
       jjtc001 = false;
     }
/*@egen*/
     {
         jjtn001.setVarName(varName);
     })/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  0);
      }
    }
/*@egen*/
}

String identifier() :
{
    Token t;
}
{
    t = <IDENTIFIER>
    {
        return t.image;
    }
}
